import { WeavyContextType } from '../client/context-definition';
import { ContextConsumer } from '@lit/context';
import { QueryClient, MutationState, MutationFilters, Mutation, DefaultError, MutationCache } from '@tanstack/query-core';
import { LitElement, ReactiveController, ReactiveControllerHost } from 'lit';

type MutationStateOptions<TResult = MutationState> = {
    filters?: MutationFilters;
    select?: (mutation: Mutation<unknown, DefaultError, unknown, unknown>) => TResult;
};
export declare class MutationStateController<TData, TError, TVariables, TContext> implements ReactiveController {
    host: ReactiveControllerHost;
    context?: ContextConsumer<{
        __context__: WeavyContextType;
    }, LitElement>;
    whenContext?: Promise<void>;
    resolveContext?: (value: void | PromiseLike<void>) => void;
    result?: MutationState<TData, TError, TVariables, TContext>[];
    mutationCache?: MutationCache;
    mutationCacheUnsubscribe?: () => void;
    alwaysUpdate: boolean;
    options?: MutationStateOptions<MutationState<TData, TError, TVariables, TContext>>;
    constructor(host: ReactiveControllerHost);
    setContext(): Promise<void>;
    hostUpdate(): void;
    trackMutationState(options: MutationStateOptions<MutationState<TData, TError, TVariables, TContext>>, queryClient?: QueryClient): Promise<MutationState<TData, TError, TVariables, TContext>[] | undefined>;
    mutationCacheSubscribe(): void;
    untrackMutationState(): void;
    hostConnected(): void;
    hostDisconnected(): void;
}
export {};
//# sourceMappingURL=mutation-state-controller.d.ts.map