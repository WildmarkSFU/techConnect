{
  "version": 3,
  "sources": ["src/modal-controller.ts"],
  "sourcesContent": ["import { ReactiveController, TemplateResult } from 'lit';\nimport { List, Map } from 'immutable';\n\nimport uuid from './lib/uuid';\nimport { MapOf, applyState, isNew } from './lib/state';\nimport ModalPortal, { ModalPortalState } from './modal-portal';\n\n/** @internal A [`TemplateResult`](https://lit.dev/docs/api/templates/#TemplateResult) with an extra property: `key`. */\nexport type KeyedTemplateResult = TemplateResult & { key: string };\n\nfunction addKeyToTemplate(el: TemplateResult, key: string): KeyedTemplateResult {\n  const keyedTemplate: KeyedTemplateResult = el as KeyedTemplateResult;\n  keyedTemplate.key = key;\n  return keyedTemplate;\n}\n\n/** Registry for a modal that offers callbacks to remove the modal or replace it with another template. */\nexport type ModalRegistry = {\n  /** Callback to remove the modal. */\n  remove: Function;\n\n  /** Callback to update the modal with a new `template` and `closeCallback` function. */\n  replace: (template: TemplateResult, closeCallback?: Function) => void;\n};\n\n/** @internal Object type parameter for [[ModalController]] state. */\nexport type ModalState = {\n  modalStack: List<KeyedTemplateResult>;\n  modalNodes: List<EventTarget>;\n  closeCallbacks: Map<string, Function>;\n};\n\nlet _modalState: MapOf<ModalState> = Map<keyof ModalState, any>({\n  modalStack: List(),\n  modalNodes: List(),\n  closeCallbacks: Map(),\n});\n\n/**\n * An extended ReactiveController interface for [[modalController]].\n */\nexport interface ModalController extends ReactiveController {\n  /** @internal */\n  host?: ModalPortal;\n\n  /** @internal */\n  modalState: MapOf<ModalState>;\n\n  /** @internal */\n  modalStack: List<KeyedTemplateResult>;\n\n  /** @internal */\n  modalNodes: List<EventTarget>;\n\n  /** @internal */\n  closeCallbacks: Map<string, Function>;\n\n  /** @internal */\n  attach: (host: ModalPortal) => void;\n\n  /**\n   * Add the given template to a new modal, placed on the top of the stack.\n   * An optional `closeCallback` function will be executed when the modal is removed from the stack.\n   *\n   * @returns A registry object that can be used to remove or replace the modal.\n   */\n  push: (template: TemplateResult, closeCallback?: Function) => ModalRegistry;\n\n  /** Removed the topmost modal from the stack. */\n  pop: () => void;\n\n  /** Removes a modal by its DOM node. */\n  removeByNode: (modal: EventTarget) => void;\n\n  /** Removes a modal by its key. */\n  removeByKey: (key: string) => void;\n\n  /** Clears the modal stack. */\n  removeAll: () => void;\n}\n\n/**\n * Private removal function via index.\n * Looks for (and executes) an associated callback function for the modal at the given index.\n * Deletes both the template and the cached DOM node at the index.\n */\nfunction removeModal(index: number) {\n  if (index >= 0) {\n    // Safeguard against negative indices, which are supported by the immutable List.\n    const key = this.modalStack.get(index)?.key;\n    const callback = this.closeCallbacks.get(key);\n    if (callback !== undefined) {\n      callback();\n    }\n\n    this.modalState = applyState(this.modalState, {\n      modalStack: this.modalStack.delete(index),\n      modalNodes: this.modalNodes.delete(index),\n      closeCallbacks: this.closeCallbacks.delete(key),\n    });\n  }\n}\n\n/** Replaces a modal with the given key, updating both the template and the closeCallback. */\nfunction replaceModal(key: string, template: TemplateResult, closeCallback?: Function) {\n  const index = this.modalStack.findIndex((kt: KeyedTemplateResult) => kt.key === key);\n  if (index >= 0) {\n    this.modalState = applyState(this.modalState, {\n      modalStack: this.modalStack.set(index, addKeyToTemplate(template, key)),\n      closeCallbacks:\n        closeCallback !== undefined\n          ? this.closeCallbacks.set(key, closeCallback)\n          : this.closeCallbacks.delete(key),\n    });\n  }\n}\n\n/**\n * A singleton Lit controller that manages the state of [[ModalPortal]].\n */\nconst modalController: ModalController = {\n  host: undefined,\n\n  set modalState(newState: MapOf<ModalState>) {\n    if (isNew(newState, 'modalStack', this.modalStack)) {\n      this.host.offerState(\n        Map<keyof ModalPortalState, any>({\n          modalStack: newState.get('modalStack'),\n        }),\n      );\n    }\n    _modalState = newState;\n  },\n\n  get modalState(): MapOf<ModalState> {\n    return _modalState;\n  },\n\n  get modalStack(): List<KeyedTemplateResult> {\n    return this.modalState.get('modalStack');\n  },\n\n  get modalNodes(): List<EventTarget> {\n    return this.modalState.get('modalNodes');\n  },\n\n  get closeCallbacks(): Map<string, Function> {\n    return this.modalState.get('closeCallbacks');\n  },\n\n  attach(host: ModalPortal) {\n    if (this.host === undefined) {\n      (this.host = host).addController(this);\n    } else {\n      console.error('You attempted to attach a singleton controller to more than one host.');\n    }\n  },\n\n  hostConnected() {\n    this.host.offerState(Map<keyof ModalPortalState, any>({ modalStack: this.modalStack }));\n  },\n\n  hostUpdated() {\n    // We need to maintain a concurrent list of the modals to support asynchronous and out-of-order modal popping.\n    this.modalState = applyState(this.modalState, {\n      modalNodes: List(this.host.modalNodes),\n    });\n  },\n\n  push(template: TemplateResult, closeCallback?: Function): ModalRegistry {\n    const key = uuid();\n    this.modalState = applyState(this.modalState, {\n      modalStack: this.modalStack.push(addKeyToTemplate(template, key)),\n      closeCallbacks:\n        closeCallback !== undefined\n          ? this.closeCallbacks.set(key, closeCallback)\n          : this.closeCallbacks,\n    });\n\n    return {\n      remove: () => this.removeByKey(key),\n      replace: (template: TemplateResult, closeCallback?: Function) =>\n        replaceModal.call(this, key, template, closeCallback),\n    };\n  },\n\n  pop() {\n    removeModal.call(this, this.modalStack.size - 1);\n  },\n\n  removeByNode(modal: EventTarget) {\n    removeModal.call(this, this.modalNodes.indexOf(modal));\n  },\n\n  removeByKey(key: string) {\n    removeModal.call(\n      this,\n      this.modalStack.findIndex((kt: KeyedTemplateResult) => kt.key === key),\n    );\n  },\n\n  removeAll() {\n    while (this.modalStack.size > 0) {\n      this.pop();\n    }\n  },\n};\n\nexport default modalController;\n"],
  "mappings": "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",
  "names": ["template", "closeCallback"]
}
